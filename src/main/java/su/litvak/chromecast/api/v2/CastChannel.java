// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/main/resources/su/litvak/justdlna/chromecast/v2/cast_channel.proto

package su.litvak.chromecast.api.v2;

public final class CastChannel {
  private CastChannel() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  /**
   * Protobuf enum {@code su.litvak.chromecast.api.v2.SignatureAlgorithm}
   */
  public enum SignatureAlgorithm
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>UNSPECIFIED = 0;</code>
     */
    UNSPECIFIED(0),
    /**
     * <code>RSASSA_PKCS1v15 = 1;</code>
     */
    RSASSA_PKCS1v15(1),
    /**
     * <code>RSASSA_PSS = 2;</code>
     */
    RSASSA_PSS(2),
    ;

    /**
     * <code>UNSPECIFIED = 0;</code>
     */
    public static final int UNSPECIFIED_VALUE = 0;
    /**
     * <code>RSASSA_PKCS1v15 = 1;</code>
     */
    public static final int RSASSA_PKCS1v15_VALUE = 1;
    /**
     * <code>RSASSA_PSS = 2;</code>
     */
    public static final int RSASSA_PSS_VALUE = 2;


    @java.lang.Override
    public final int getNumber() {
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SignatureAlgorithm valueOf(int value) {
      return forNumber(value);
    }

    public static SignatureAlgorithm forNumber(int value) {
      switch (value) {
        case 0: return UNSPECIFIED;
        case 1: return RSASSA_PKCS1v15;
        case 2: return RSASSA_PSS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SignatureAlgorithm>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SignatureAlgorithm> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SignatureAlgorithm>() {
            @java.lang.Override
            public SignatureAlgorithm findValueByNumber(int number) {
              return SignatureAlgorithm.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return SignatureAlgorithmVerifier.INSTANCE;
    }

    private static final class SignatureAlgorithmVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SignatureAlgorithmVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return SignatureAlgorithm.forNumber(number) != null;
            }
          };

    private final int value;

    private SignatureAlgorithm(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:su.litvak.chromecast.api.v2.SignatureAlgorithm)
  }

  public interface CastMessageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:su.litvak.chromecast.api.v2.CastMessage)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
     * @return Whether the protocolVersion field is set.
     */
    boolean hasProtocolVersion();
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
     * @return The protocolVersion.
     */
    su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion getProtocolVersion();

    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     * @return Whether the sourceId field is set.
     */
    boolean hasSourceId();
    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     * @return The sourceId.
     */
    java.lang.String getSourceId();
    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     * @return The bytes for sourceId.
     */
    com.google.protobuf.ByteString
        getSourceIdBytes();

    /**
     * <code>required string destination_id = 3;</code>
     * @return Whether the destinationId field is set.
     */
    boolean hasDestinationId();
    /**
     * <code>required string destination_id = 3;</code>
     * @return The destinationId.
     */
    java.lang.String getDestinationId();
    /**
     * <code>required string destination_id = 3;</code>
     * @return The bytes for destinationId.
     */
    com.google.protobuf.ByteString
        getDestinationIdBytes();

    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     * @return Whether the namespace field is set.
     */
    boolean hasNamespace();
    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     * @return The namespace.
     */
    java.lang.String getNamespace();
    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     * @return The bytes for namespace.
     */
    com.google.protobuf.ByteString
        getNamespaceBytes();

    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
     * @return Whether the payloadType field is set.
     */
    boolean hasPayloadType();
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
     * @return The payloadType.
     */
    su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType getPayloadType();

    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     * @return Whether the payloadUtf8 field is set.
     */
    boolean hasPayloadUtf8();
    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     * @return The payloadUtf8.
     */
    java.lang.String getPayloadUtf8();
    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     * @return The bytes for payloadUtf8.
     */
    com.google.protobuf.ByteString
        getPayloadUtf8Bytes();

    /**
     * <code>optional bytes payload_binary = 7;</code>
     * @return Whether the payloadBinary field is set.
     */
    boolean hasPayloadBinary();
    /**
     * <code>optional bytes payload_binary = 7;</code>
     * @return The payloadBinary.
     */
    com.google.protobuf.ByteString getPayloadBinary();
  }
  /**
   * Protobuf type {@code su.litvak.chromecast.api.v2.CastMessage}
   */
  public  static final class CastMessage extends
      com.google.protobuf.GeneratedMessageLite<
          CastMessage, CastMessage.Builder> implements
      // @@protoc_insertion_point(message_implements:su.litvak.chromecast.api.v2.CastMessage)
      CastMessageOrBuilder {
    private CastMessage() {
      sourceId_ = "";
      destinationId_ = "";
      namespace_ = "";
      payloadUtf8_ = "";
      payloadBinary_ = com.google.protobuf.ByteString.EMPTY;
    }
    /**
     * <pre>
     * Always pass a version of the protocol for future compatibility
     * requirements.
     * </pre>
     *
     * Protobuf enum {@code su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion}
     */
    public enum ProtocolVersion
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>CASTV2_1_0 = 0;</code>
       */
      CASTV2_1_0(0),
      ;

      /**
       * <code>CASTV2_1_0 = 0;</code>
       */
      public static final int CASTV2_1_0_VALUE = 0;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ProtocolVersion valueOf(int value) {
        return forNumber(value);
      }

      public static ProtocolVersion forNumber(int value) {
        switch (value) {
          case 0: return CASTV2_1_0;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ProtocolVersion>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ProtocolVersion> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ProtocolVersion>() {
              @java.lang.Override
              public ProtocolVersion findValueByNumber(int number) {
                return ProtocolVersion.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ProtocolVersionVerifier.INSTANCE;
      }

      private static final class ProtocolVersionVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ProtocolVersionVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ProtocolVersion.forNumber(number) != null;
              }
            };

      private final int value;

      private ProtocolVersion(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion)
    }

    /**
     * <pre>
     * What type of data do we have in this message.
     * </pre>
     *
     * Protobuf enum {@code su.litvak.chromecast.api.v2.CastMessage.PayloadType}
     */
    public enum PayloadType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>STRING = 0;</code>
       */
      STRING(0),
      /**
       * <code>BINARY = 1;</code>
       */
      BINARY(1),
      ;

      /**
       * <code>STRING = 0;</code>
       */
      public static final int STRING_VALUE = 0;
      /**
       * <code>BINARY = 1;</code>
       */
      public static final int BINARY_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PayloadType valueOf(int value) {
        return forNumber(value);
      }

      public static PayloadType forNumber(int value) {
        switch (value) {
          case 0: return STRING;
          case 1: return BINARY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PayloadType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PayloadType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PayloadType>() {
              @java.lang.Override
              public PayloadType findValueByNumber(int number) {
                return PayloadType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return PayloadTypeVerifier.INSTANCE;
      }

      private static final class PayloadTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new PayloadTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return PayloadType.forNumber(number) != null;
              }
            };

      private final int value;

      private PayloadType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:su.litvak.chromecast.api.v2.CastMessage.PayloadType)
    }

    private int bitField0_;
    public static final int PROTOCOL_VERSION_FIELD_NUMBER = 1;
    private int protocolVersion_;
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
     * @return Whether the protocolVersion field is set.
     */
    @java.lang.Override
    public boolean hasProtocolVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
     * @return The protocolVersion.
     */
    @java.lang.Override
    public su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion getProtocolVersion() {
      su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion result = su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion.forNumber(protocolVersion_);
      return result == null ? su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion.CASTV2_1_0 : result;
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
     * @param value The protocolVersion to set.
     */
    private void setProtocolVersion(su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion value) {
      protocolVersion_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
     */
    private void clearProtocolVersion() {
      bitField0_ = (bitField0_ & ~0x00000001);
      protocolVersion_ = 0;
    }

    public static final int SOURCE_ID_FIELD_NUMBER = 2;
    private java.lang.String sourceId_;
    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     * @return Whether the sourceId field is set.
     */
    @java.lang.Override
    public boolean hasSourceId() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     * @return The sourceId.
     */
    @java.lang.Override
    public java.lang.String getSourceId() {
      return sourceId_;
    }
    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     * @return The bytes for sourceId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSourceIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(sourceId_);
    }
    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     * @param value The sourceId to set.
     */
    private void setSourceId(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      sourceId_ = value;
    }
    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     */
    private void clearSourceId() {
      bitField0_ = (bitField0_ & ~0x00000002);
      sourceId_ = getDefaultInstance().getSourceId();
    }
    /**
     * <pre>
     * source and destination ids identify the origin and destination of the
     * message.  They are used to route messages between endpoints that share a
     * device-to-device channel.
     * For messages between applications:
     *   - The sender application id is a unique identifier generated on behalf of
     *     the sender application.
     *   - The receiver id is always the the session id for the application.
     * For messages to or from the sender or receiver platform, the special ids
     * 'sender-0' and 'receiver-0' can be used.
     * For messages intended for all endpoints using a given channel, the
     * wildcard destination_id '*' can be used.
     * </pre>
     *
     * <code>required string source_id = 2;</code>
     * @param value The bytes for sourceId to set.
     */
    private void setSourceIdBytes(
        com.google.protobuf.ByteString value) {
      sourceId_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int DESTINATION_ID_FIELD_NUMBER = 3;
    private java.lang.String destinationId_;
    /**
     * <code>required string destination_id = 3;</code>
     * @return Whether the destinationId field is set.
     */
    @java.lang.Override
    public boolean hasDestinationId() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>required string destination_id = 3;</code>
     * @return The destinationId.
     */
    @java.lang.Override
    public java.lang.String getDestinationId() {
      return destinationId_;
    }
    /**
     * <code>required string destination_id = 3;</code>
     * @return The bytes for destinationId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDestinationIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(destinationId_);
    }
    /**
     * <code>required string destination_id = 3;</code>
     * @param value The destinationId to set.
     */
    private void setDestinationId(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      destinationId_ = value;
    }
    /**
     * <code>required string destination_id = 3;</code>
     */
    private void clearDestinationId() {
      bitField0_ = (bitField0_ & ~0x00000004);
      destinationId_ = getDefaultInstance().getDestinationId();
    }
    /**
     * <code>required string destination_id = 3;</code>
     * @param value The bytes for destinationId to set.
     */
    private void setDestinationIdBytes(
        com.google.protobuf.ByteString value) {
      destinationId_ = value.toStringUtf8();
      bitField0_ |= 0x00000004;
    }

    public static final int NAMESPACE_FIELD_NUMBER = 4;
    private java.lang.String namespace_;
    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     * @return Whether the namespace field is set.
     */
    @java.lang.Override
    public boolean hasNamespace() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     * @return The namespace.
     */
    @java.lang.Override
    public java.lang.String getNamespace() {
      return namespace_;
    }
    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     * @return The bytes for namespace.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNamespaceBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(namespace_);
    }
    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     * @param value The namespace to set.
     */
    private void setNamespace(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000008;
      namespace_ = value;
    }
    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     */
    private void clearNamespace() {
      bitField0_ = (bitField0_ & ~0x00000008);
      namespace_ = getDefaultInstance().getNamespace();
    }
    /**
     * <pre>
     * This is the core multiplexing key.  All messages are sent on a namespace
     * and endpoints sharing a channel listen on one or more namespaces.  The
     * namespace defines the protocol and semantics of the message.
     * </pre>
     *
     * <code>required string namespace = 4;</code>
     * @param value The bytes for namespace to set.
     */
    private void setNamespaceBytes(
        com.google.protobuf.ByteString value) {
      namespace_ = value.toStringUtf8();
      bitField0_ |= 0x00000008;
    }

    public static final int PAYLOAD_TYPE_FIELD_NUMBER = 5;
    private int payloadType_;
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
     * @return Whether the payloadType field is set.
     */
    @java.lang.Override
    public boolean hasPayloadType() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
     * @return The payloadType.
     */
    @java.lang.Override
    public su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType getPayloadType() {
      su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType result = su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType.forNumber(payloadType_);
      return result == null ? su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType.STRING : result;
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
     * @param value The payloadType to set.
     */
    private void setPayloadType(su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType value) {
      payloadType_ = value.getNumber();
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
     */
    private void clearPayloadType() {
      bitField0_ = (bitField0_ & ~0x00000010);
      payloadType_ = 0;
    }

    public static final int PAYLOAD_UTF8_FIELD_NUMBER = 6;
    private java.lang.String payloadUtf8_;
    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     * @return Whether the payloadUtf8 field is set.
     */
    @java.lang.Override
    public boolean hasPayloadUtf8() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     * @return The payloadUtf8.
     */
    @java.lang.Override
    public java.lang.String getPayloadUtf8() {
      return payloadUtf8_;
    }
    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     * @return The bytes for payloadUtf8.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPayloadUtf8Bytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(payloadUtf8_);
    }
    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     * @param value The payloadUtf8 to set.
     */
    private void setPayloadUtf8(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000020;
      payloadUtf8_ = value;
    }
    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     */
    private void clearPayloadUtf8() {
      bitField0_ = (bitField0_ & ~0x00000020);
      payloadUtf8_ = getDefaultInstance().getPayloadUtf8();
    }
    /**
     * <pre>
     * Depending on payload_type, exactly one of the following optional fields
     * will always be set.
     * </pre>
     *
     * <code>optional string payload_utf8 = 6;</code>
     * @param value The bytes for payloadUtf8 to set.
     */
    private void setPayloadUtf8Bytes(
        com.google.protobuf.ByteString value) {
      payloadUtf8_ = value.toStringUtf8();
      bitField0_ |= 0x00000020;
    }

    public static final int PAYLOAD_BINARY_FIELD_NUMBER = 7;
    private com.google.protobuf.ByteString payloadBinary_;
    /**
     * <code>optional bytes payload_binary = 7;</code>
     * @return Whether the payloadBinary field is set.
     */
    @java.lang.Override
    public boolean hasPayloadBinary() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional bytes payload_binary = 7;</code>
     * @return The payloadBinary.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPayloadBinary() {
      return payloadBinary_;
    }
    /**
     * <code>optional bytes payload_binary = 7;</code>
     * @param value The payloadBinary to set.
     */
    private void setPayloadBinary(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000040;
      payloadBinary_ = value;
    }
    /**
     * <code>optional bytes payload_binary = 7;</code>
     */
    private void clearPayloadBinary() {
      bitField0_ = (bitField0_ & ~0x00000040);
      payloadBinary_ = getDefaultInstance().getPayloadBinary();
    }

    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(su.litvak.chromecast.api.v2.CastChannel.CastMessage prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code su.litvak.chromecast.api.v2.CastMessage}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          su.litvak.chromecast.api.v2.CastChannel.CastMessage, Builder> implements
        // @@protoc_insertion_point(builder_implements:su.litvak.chromecast.api.v2.CastMessage)
        su.litvak.chromecast.api.v2.CastChannel.CastMessageOrBuilder {
      // Construct using su.litvak.chromecast.api.v2.CastChannel.CastMessage.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
       * @return Whether the protocolVersion field is set.
       */
      @java.lang.Override
      public boolean hasProtocolVersion() {
        return instance.hasProtocolVersion();
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
       * @return The protocolVersion.
       */
      @java.lang.Override
      public su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion getProtocolVersion() {
        return instance.getProtocolVersion();
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
       * @param value The enum numeric value on the wire for protocolVersion to set.
       * @return This builder for chaining.
       */
      public Builder setProtocolVersion(su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion value) {
        copyOnWrite();
        instance.setProtocolVersion(value);
        return this;
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.CastMessage.ProtocolVersion protocol_version = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearProtocolVersion() {
        copyOnWrite();
        instance.clearProtocolVersion();
        return this;
      }

      /**
       * <pre>
       * source and destination ids identify the origin and destination of the
       * message.  They are used to route messages between endpoints that share a
       * device-to-device channel.
       * For messages between applications:
       *   - The sender application id is a unique identifier generated on behalf of
       *     the sender application.
       *   - The receiver id is always the the session id for the application.
       * For messages to or from the sender or receiver platform, the special ids
       * 'sender-0' and 'receiver-0' can be used.
       * For messages intended for all endpoints using a given channel, the
       * wildcard destination_id '*' can be used.
       * </pre>
       *
       * <code>required string source_id = 2;</code>
       * @return Whether the sourceId field is set.
       */
      @java.lang.Override
      public boolean hasSourceId() {
        return instance.hasSourceId();
      }
      /**
       * <pre>
       * source and destination ids identify the origin and destination of the
       * message.  They are used to route messages between endpoints that share a
       * device-to-device channel.
       * For messages between applications:
       *   - The sender application id is a unique identifier generated on behalf of
       *     the sender application.
       *   - The receiver id is always the the session id for the application.
       * For messages to or from the sender or receiver platform, the special ids
       * 'sender-0' and 'receiver-0' can be used.
       * For messages intended for all endpoints using a given channel, the
       * wildcard destination_id '*' can be used.
       * </pre>
       *
       * <code>required string source_id = 2;</code>
       * @return The sourceId.
       */
      @java.lang.Override
      public java.lang.String getSourceId() {
        return instance.getSourceId();
      }
      /**
       * <pre>
       * source and destination ids identify the origin and destination of the
       * message.  They are used to route messages between endpoints that share a
       * device-to-device channel.
       * For messages between applications:
       *   - The sender application id is a unique identifier generated on behalf of
       *     the sender application.
       *   - The receiver id is always the the session id for the application.
       * For messages to or from the sender or receiver platform, the special ids
       * 'sender-0' and 'receiver-0' can be used.
       * For messages intended for all endpoints using a given channel, the
       * wildcard destination_id '*' can be used.
       * </pre>
       *
       * <code>required string source_id = 2;</code>
       * @return The bytes for sourceId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSourceIdBytes() {
        return instance.getSourceIdBytes();
      }
      /**
       * <pre>
       * source and destination ids identify the origin and destination of the
       * message.  They are used to route messages between endpoints that share a
       * device-to-device channel.
       * For messages between applications:
       *   - The sender application id is a unique identifier generated on behalf of
       *     the sender application.
       *   - The receiver id is always the the session id for the application.
       * For messages to or from the sender or receiver platform, the special ids
       * 'sender-0' and 'receiver-0' can be used.
       * For messages intended for all endpoints using a given channel, the
       * wildcard destination_id '*' can be used.
       * </pre>
       *
       * <code>required string source_id = 2;</code>
       * @param value The sourceId to set.
       * @return This builder for chaining.
       */
      public Builder setSourceId(
          java.lang.String value) {
        copyOnWrite();
        instance.setSourceId(value);
        return this;
      }
      /**
       * <pre>
       * source and destination ids identify the origin and destination of the
       * message.  They are used to route messages between endpoints that share a
       * device-to-device channel.
       * For messages between applications:
       *   - The sender application id is a unique identifier generated on behalf of
       *     the sender application.
       *   - The receiver id is always the the session id for the application.
       * For messages to or from the sender or receiver platform, the special ids
       * 'sender-0' and 'receiver-0' can be used.
       * For messages intended for all endpoints using a given channel, the
       * wildcard destination_id '*' can be used.
       * </pre>
       *
       * <code>required string source_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSourceId() {
        copyOnWrite();
        instance.clearSourceId();
        return this;
      }
      /**
       * <pre>
       * source and destination ids identify the origin and destination of the
       * message.  They are used to route messages between endpoints that share a
       * device-to-device channel.
       * For messages between applications:
       *   - The sender application id is a unique identifier generated on behalf of
       *     the sender application.
       *   - The receiver id is always the the session id for the application.
       * For messages to or from the sender or receiver platform, the special ids
       * 'sender-0' and 'receiver-0' can be used.
       * For messages intended for all endpoints using a given channel, the
       * wildcard destination_id '*' can be used.
       * </pre>
       *
       * <code>required string source_id = 2;</code>
       * @param value The bytes for sourceId to set.
       * @return This builder for chaining.
       */
      public Builder setSourceIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSourceIdBytes(value);
        return this;
      }

      /**
       * <code>required string destination_id = 3;</code>
       * @return Whether the destinationId field is set.
       */
      @java.lang.Override
      public boolean hasDestinationId() {
        return instance.hasDestinationId();
      }
      /**
       * <code>required string destination_id = 3;</code>
       * @return The destinationId.
       */
      @java.lang.Override
      public java.lang.String getDestinationId() {
        return instance.getDestinationId();
      }
      /**
       * <code>required string destination_id = 3;</code>
       * @return The bytes for destinationId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDestinationIdBytes() {
        return instance.getDestinationIdBytes();
      }
      /**
       * <code>required string destination_id = 3;</code>
       * @param value The destinationId to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationId(
          java.lang.String value) {
        copyOnWrite();
        instance.setDestinationId(value);
        return this;
      }
      /**
       * <code>required string destination_id = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDestinationId() {
        copyOnWrite();
        instance.clearDestinationId();
        return this;
      }
      /**
       * <code>required string destination_id = 3;</code>
       * @param value The bytes for destinationId to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDestinationIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * This is the core multiplexing key.  All messages are sent on a namespace
       * and endpoints sharing a channel listen on one or more namespaces.  The
       * namespace defines the protocol and semantics of the message.
       * </pre>
       *
       * <code>required string namespace = 4;</code>
       * @return Whether the namespace field is set.
       */
      @java.lang.Override
      public boolean hasNamespace() {
        return instance.hasNamespace();
      }
      /**
       * <pre>
       * This is the core multiplexing key.  All messages are sent on a namespace
       * and endpoints sharing a channel listen on one or more namespaces.  The
       * namespace defines the protocol and semantics of the message.
       * </pre>
       *
       * <code>required string namespace = 4;</code>
       * @return The namespace.
       */
      @java.lang.Override
      public java.lang.String getNamespace() {
        return instance.getNamespace();
      }
      /**
       * <pre>
       * This is the core multiplexing key.  All messages are sent on a namespace
       * and endpoints sharing a channel listen on one or more namespaces.  The
       * namespace defines the protocol and semantics of the message.
       * </pre>
       *
       * <code>required string namespace = 4;</code>
       * @return The bytes for namespace.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNamespaceBytes() {
        return instance.getNamespaceBytes();
      }
      /**
       * <pre>
       * This is the core multiplexing key.  All messages are sent on a namespace
       * and endpoints sharing a channel listen on one or more namespaces.  The
       * namespace defines the protocol and semantics of the message.
       * </pre>
       *
       * <code>required string namespace = 4;</code>
       * @param value The namespace to set.
       * @return This builder for chaining.
       */
      public Builder setNamespace(
          java.lang.String value) {
        copyOnWrite();
        instance.setNamespace(value);
        return this;
      }
      /**
       * <pre>
       * This is the core multiplexing key.  All messages are sent on a namespace
       * and endpoints sharing a channel listen on one or more namespaces.  The
       * namespace defines the protocol and semantics of the message.
       * </pre>
       *
       * <code>required string namespace = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearNamespace() {
        copyOnWrite();
        instance.clearNamespace();
        return this;
      }
      /**
       * <pre>
       * This is the core multiplexing key.  All messages are sent on a namespace
       * and endpoints sharing a channel listen on one or more namespaces.  The
       * namespace defines the protocol and semantics of the message.
       * </pre>
       *
       * <code>required string namespace = 4;</code>
       * @param value The bytes for namespace to set.
       * @return This builder for chaining.
       */
      public Builder setNamespaceBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNamespaceBytes(value);
        return this;
      }

      /**
       * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
       * @return Whether the payloadType field is set.
       */
      @java.lang.Override
      public boolean hasPayloadType() {
        return instance.hasPayloadType();
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
       * @return The payloadType.
       */
      @java.lang.Override
      public su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType getPayloadType() {
        return instance.getPayloadType();
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
       * @param value The enum numeric value on the wire for payloadType to set.
       * @return This builder for chaining.
       */
      public Builder setPayloadType(su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType value) {
        copyOnWrite();
        instance.setPayloadType(value);
        return this;
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.CastMessage.PayloadType payload_type = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPayloadType() {
        copyOnWrite();
        instance.clearPayloadType();
        return this;
      }

      /**
       * <pre>
       * Depending on payload_type, exactly one of the following optional fields
       * will always be set.
       * </pre>
       *
       * <code>optional string payload_utf8 = 6;</code>
       * @return Whether the payloadUtf8 field is set.
       */
      @java.lang.Override
      public boolean hasPayloadUtf8() {
        return instance.hasPayloadUtf8();
      }
      /**
       * <pre>
       * Depending on payload_type, exactly one of the following optional fields
       * will always be set.
       * </pre>
       *
       * <code>optional string payload_utf8 = 6;</code>
       * @return The payloadUtf8.
       */
      @java.lang.Override
      public java.lang.String getPayloadUtf8() {
        return instance.getPayloadUtf8();
      }
      /**
       * <pre>
       * Depending on payload_type, exactly one of the following optional fields
       * will always be set.
       * </pre>
       *
       * <code>optional string payload_utf8 = 6;</code>
       * @return The bytes for payloadUtf8.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPayloadUtf8Bytes() {
        return instance.getPayloadUtf8Bytes();
      }
      /**
       * <pre>
       * Depending on payload_type, exactly one of the following optional fields
       * will always be set.
       * </pre>
       *
       * <code>optional string payload_utf8 = 6;</code>
       * @param value The payloadUtf8 to set.
       * @return This builder for chaining.
       */
      public Builder setPayloadUtf8(
          java.lang.String value) {
        copyOnWrite();
        instance.setPayloadUtf8(value);
        return this;
      }
      /**
       * <pre>
       * Depending on payload_type, exactly one of the following optional fields
       * will always be set.
       * </pre>
       *
       * <code>optional string payload_utf8 = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearPayloadUtf8() {
        copyOnWrite();
        instance.clearPayloadUtf8();
        return this;
      }
      /**
       * <pre>
       * Depending on payload_type, exactly one of the following optional fields
       * will always be set.
       * </pre>
       *
       * <code>optional string payload_utf8 = 6;</code>
       * @param value The bytes for payloadUtf8 to set.
       * @return This builder for chaining.
       */
      public Builder setPayloadUtf8Bytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPayloadUtf8Bytes(value);
        return this;
      }

      /**
       * <code>optional bytes payload_binary = 7;</code>
       * @return Whether the payloadBinary field is set.
       */
      @java.lang.Override
      public boolean hasPayloadBinary() {
        return instance.hasPayloadBinary();
      }
      /**
       * <code>optional bytes payload_binary = 7;</code>
       * @return The payloadBinary.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPayloadBinary() {
        return instance.getPayloadBinary();
      }
      /**
       * <code>optional bytes payload_binary = 7;</code>
       * @param value The payloadBinary to set.
       * @return This builder for chaining.
       */
      public Builder setPayloadBinary(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPayloadBinary(value);
        return this;
      }
      /**
       * <code>optional bytes payload_binary = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearPayloadBinary() {
        copyOnWrite();
        instance.clearPayloadBinary();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:su.litvak.chromecast.api.v2.CastMessage)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new su.litvak.chromecast.api.v2.CastChannel.CastMessage();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "protocolVersion_",
              su.litvak.chromecast.api.v2.CastChannel.CastMessage.ProtocolVersion.internalGetVerifier(),
              "sourceId_",
              "destinationId_",
              "namespace_",
              "payloadType_",
              su.litvak.chromecast.api.v2.CastChannel.CastMessage.PayloadType.internalGetVerifier(),
              "payloadUtf8_",
              "payloadBinary_",
            };
            java.lang.String info =
                "\u0001\u0007\u0000\u0001\u0001\u0007\u0007\u0000\u0000\u0005\u0001\u150c\u0000\u0002" +
                "\u1508\u0001\u0003\u1508\u0002\u0004\u1508\u0003\u0005\u150c\u0004\u0006\u1008\u0005" +
                "\u0007\u100a\u0006";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<su.litvak.chromecast.api.v2.CastChannel.CastMessage> parser = PARSER;
          if (parser == null) {
            synchronized (su.litvak.chromecast.api.v2.CastChannel.CastMessage.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<su.litvak.chromecast.api.v2.CastChannel.CastMessage>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:su.litvak.chromecast.api.v2.CastMessage)
    private static final su.litvak.chromecast.api.v2.CastChannel.CastMessage DEFAULT_INSTANCE;
    static {
      CastMessage defaultInstance = new CastMessage();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        CastMessage.class, defaultInstance);
    }

    public static su.litvak.chromecast.api.v2.CastChannel.CastMessage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<CastMessage> PARSER;

    public static com.google.protobuf.Parser<CastMessage> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AuthChallengeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:su.litvak.chromecast.api.v2.AuthChallenge)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
     * @return Whether the signatureAlgorithm field is set.
     */
    boolean hasSignatureAlgorithm();
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
     * @return The signatureAlgorithm.
     */
    su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm getSignatureAlgorithm();
  }
  /**
   * <pre>
   * Messages for authentication protocol between a sender and a receiver.
   * </pre>
   *
   * Protobuf type {@code su.litvak.chromecast.api.v2.AuthChallenge}
   */
  public  static final class AuthChallenge extends
      com.google.protobuf.GeneratedMessageLite<
          AuthChallenge, AuthChallenge.Builder> implements
      // @@protoc_insertion_point(message_implements:su.litvak.chromecast.api.v2.AuthChallenge)
      AuthChallengeOrBuilder {
    private AuthChallenge() {
      signatureAlgorithm_ = 1;
    }
    private int bitField0_;
    public static final int SIGNATURE_ALGORITHM_FIELD_NUMBER = 1;
    private int signatureAlgorithm_;
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
     * @return Whether the signatureAlgorithm field is set.
     */
    @java.lang.Override
    public boolean hasSignatureAlgorithm() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
     * @return The signatureAlgorithm.
     */
    @java.lang.Override
    public su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm getSignatureAlgorithm() {
      su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm result = su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm.forNumber(signatureAlgorithm_);
      return result == null ? su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15 : result;
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
     * @param value The signatureAlgorithm to set.
     */
    private void setSignatureAlgorithm(su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm value) {
      signatureAlgorithm_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
     */
    private void clearSignatureAlgorithm() {
      bitField0_ = (bitField0_ & ~0x00000001);
      signatureAlgorithm_ = 1;
    }

    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(su.litvak.chromecast.api.v2.CastChannel.AuthChallenge prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Messages for authentication protocol between a sender and a receiver.
     * </pre>
     *
     * Protobuf type {@code su.litvak.chromecast.api.v2.AuthChallenge}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          su.litvak.chromecast.api.v2.CastChannel.AuthChallenge, Builder> implements
        // @@protoc_insertion_point(builder_implements:su.litvak.chromecast.api.v2.AuthChallenge)
        su.litvak.chromecast.api.v2.CastChannel.AuthChallengeOrBuilder {
      // Construct using su.litvak.chromecast.api.v2.CastChannel.AuthChallenge.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
       * @return Whether the signatureAlgorithm field is set.
       */
      @java.lang.Override
      public boolean hasSignatureAlgorithm() {
        return instance.hasSignatureAlgorithm();
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
       * @return The signatureAlgorithm.
       */
      @java.lang.Override
      public su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm getSignatureAlgorithm() {
        return instance.getSignatureAlgorithm();
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
       * @param value The enum numeric value on the wire for signatureAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureAlgorithm(su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm value) {
        copyOnWrite();
        instance.setSignatureAlgorithm(value);
        return this;
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 1 [default = RSASSA_PKCS1v15];</code>
       * @return This builder for chaining.
       */
      public Builder clearSignatureAlgorithm() {
        copyOnWrite();
        instance.clearSignatureAlgorithm();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:su.litvak.chromecast.api.v2.AuthChallenge)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new su.litvak.chromecast.api.v2.CastChannel.AuthChallenge();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "signatureAlgorithm_",
              su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u100c\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<su.litvak.chromecast.api.v2.CastChannel.AuthChallenge> parser = PARSER;
          if (parser == null) {
            synchronized (su.litvak.chromecast.api.v2.CastChannel.AuthChallenge.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<su.litvak.chromecast.api.v2.CastChannel.AuthChallenge>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:su.litvak.chromecast.api.v2.AuthChallenge)
    private static final su.litvak.chromecast.api.v2.CastChannel.AuthChallenge DEFAULT_INSTANCE;
    static {
      AuthChallenge defaultInstance = new AuthChallenge();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        AuthChallenge.class, defaultInstance);
    }

    public static su.litvak.chromecast.api.v2.CastChannel.AuthChallenge getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AuthChallenge> PARSER;

    public static com.google.protobuf.Parser<AuthChallenge> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AuthResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:su.litvak.chromecast.api.v2.AuthResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required bytes signature = 1;</code>
     * @return Whether the signature field is set.
     */
    boolean hasSignature();
    /**
     * <code>required bytes signature = 1;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();

    /**
     * <code>required bytes client_auth_certificate = 2;</code>
     * @return Whether the clientAuthCertificate field is set.
     */
    boolean hasClientAuthCertificate();
    /**
     * <code>required bytes client_auth_certificate = 2;</code>
     * @return The clientAuthCertificate.
     */
    com.google.protobuf.ByteString getClientAuthCertificate();

    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @return A list containing the intermediateCertificate.
     */
    java.util.List<com.google.protobuf.ByteString> getIntermediateCertificateList();
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @return The count of intermediateCertificate.
     */
    int getIntermediateCertificateCount();
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @param index The index of the element to return.
     * @return The intermediateCertificate at the given index.
     */
    com.google.protobuf.ByteString getIntermediateCertificate(int index);

    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
     * @return Whether the signatureAlgorithm field is set.
     */
    boolean hasSignatureAlgorithm();
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
     * @return The signatureAlgorithm.
     */
    su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm getSignatureAlgorithm();
  }
  /**
   * Protobuf type {@code su.litvak.chromecast.api.v2.AuthResponse}
   */
  public  static final class AuthResponse extends
      com.google.protobuf.GeneratedMessageLite<
          AuthResponse, AuthResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:su.litvak.chromecast.api.v2.AuthResponse)
      AuthResponseOrBuilder {
    private AuthResponse() {
      signature_ = com.google.protobuf.ByteString.EMPTY;
      clientAuthCertificate_ = com.google.protobuf.ByteString.EMPTY;
      intermediateCertificate_ = emptyProtobufList();
      signatureAlgorithm_ = 1;
    }
    private int bitField0_;
    public static final int SIGNATURE_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString signature_;
    /**
     * <code>required bytes signature = 1;</code>
     * @return Whether the signature field is set.
     */
    @java.lang.Override
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required bytes signature = 1;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <code>required bytes signature = 1;</code>
     * @param value The signature to set.
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      signature_ = value;
    }
    /**
     * <code>required bytes signature = 1;</code>
     */
    private void clearSignature() {
      bitField0_ = (bitField0_ & ~0x00000001);
      signature_ = getDefaultInstance().getSignature();
    }

    public static final int CLIENT_AUTH_CERTIFICATE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString clientAuthCertificate_;
    /**
     * <code>required bytes client_auth_certificate = 2;</code>
     * @return Whether the clientAuthCertificate field is set.
     */
    @java.lang.Override
    public boolean hasClientAuthCertificate() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>required bytes client_auth_certificate = 2;</code>
     * @return The clientAuthCertificate.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getClientAuthCertificate() {
      return clientAuthCertificate_;
    }
    /**
     * <code>required bytes client_auth_certificate = 2;</code>
     * @param value The clientAuthCertificate to set.
     */
    private void setClientAuthCertificate(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      clientAuthCertificate_ = value;
    }
    /**
     * <code>required bytes client_auth_certificate = 2;</code>
     */
    private void clearClientAuthCertificate() {
      bitField0_ = (bitField0_ & ~0x00000002);
      clientAuthCertificate_ = getDefaultInstance().getClientAuthCertificate();
    }

    public static final int INTERMEDIATE_CERTIFICATE_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> intermediateCertificate_;
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @return A list containing the intermediateCertificate.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getIntermediateCertificateList() {
      return intermediateCertificate_;
    }
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @return The count of intermediateCertificate.
     */
    @java.lang.Override
    public int getIntermediateCertificateCount() {
      return intermediateCertificate_.size();
    }
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @param index The index of the element to return.
     * @return The intermediateCertificate at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getIntermediateCertificate(int index) {
      return intermediateCertificate_.get(index);
    }
    private void ensureIntermediateCertificateIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> tmp = intermediateCertificate_;
      if (!tmp.isModifiable()) {
        intermediateCertificate_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @param index The index to set the value at.
     * @param value The intermediateCertificate to set.
     */
    private void setIntermediateCertificate(
        int index, com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureIntermediateCertificateIsMutable();
      intermediateCertificate_.set(index, value);
    }
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @param value The intermediateCertificate to add.
     */
    private void addIntermediateCertificate(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureIntermediateCertificateIsMutable();
      intermediateCertificate_.add(value);
    }
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     * @param values The intermediateCertificate to add.
     */
    private void addAllIntermediateCertificate(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      ensureIntermediateCertificateIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, intermediateCertificate_);
    }
    /**
     * <code>repeated bytes intermediate_certificate = 3;</code>
     */
    private void clearIntermediateCertificate() {
      intermediateCertificate_ = emptyProtobufList();
    }

    public static final int SIGNATURE_ALGORITHM_FIELD_NUMBER = 4;
    private int signatureAlgorithm_;
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
     * @return Whether the signatureAlgorithm field is set.
     */
    @java.lang.Override
    public boolean hasSignatureAlgorithm() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
     * @return The signatureAlgorithm.
     */
    @java.lang.Override
    public su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm getSignatureAlgorithm() {
      su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm result = su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm.forNumber(signatureAlgorithm_);
      return result == null ? su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm.RSASSA_PKCS1v15 : result;
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
     * @param value The signatureAlgorithm to set.
     */
    private void setSignatureAlgorithm(su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm value) {
      signatureAlgorithm_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
     */
    private void clearSignatureAlgorithm() {
      bitField0_ = (bitField0_ & ~0x00000004);
      signatureAlgorithm_ = 1;
    }

    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(su.litvak.chromecast.api.v2.CastChannel.AuthResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code su.litvak.chromecast.api.v2.AuthResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          su.litvak.chromecast.api.v2.CastChannel.AuthResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:su.litvak.chromecast.api.v2.AuthResponse)
        su.litvak.chromecast.api.v2.CastChannel.AuthResponseOrBuilder {
      // Construct using su.litvak.chromecast.api.v2.CastChannel.AuthResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required bytes signature = 1;</code>
       * @return Whether the signature field is set.
       */
      @java.lang.Override
      public boolean hasSignature() {
        return instance.hasSignature();
      }
      /**
       * <code>required bytes signature = 1;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <code>required bytes signature = 1;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <code>required bytes signature = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      /**
       * <code>required bytes client_auth_certificate = 2;</code>
       * @return Whether the clientAuthCertificate field is set.
       */
      @java.lang.Override
      public boolean hasClientAuthCertificate() {
        return instance.hasClientAuthCertificate();
      }
      /**
       * <code>required bytes client_auth_certificate = 2;</code>
       * @return The clientAuthCertificate.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getClientAuthCertificate() {
        return instance.getClientAuthCertificate();
      }
      /**
       * <code>required bytes client_auth_certificate = 2;</code>
       * @param value The clientAuthCertificate to set.
       * @return This builder for chaining.
       */
      public Builder setClientAuthCertificate(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setClientAuthCertificate(value);
        return this;
      }
      /**
       * <code>required bytes client_auth_certificate = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearClientAuthCertificate() {
        copyOnWrite();
        instance.clearClientAuthCertificate();
        return this;
      }

      /**
       * <code>repeated bytes intermediate_certificate = 3;</code>
       * @return A list containing the intermediateCertificate.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.ByteString>
          getIntermediateCertificateList() {
        return java.util.Collections.unmodifiableList(
            instance.getIntermediateCertificateList());
      }
      /**
       * <code>repeated bytes intermediate_certificate = 3;</code>
       * @return The count of intermediateCertificate.
       */
      @java.lang.Override
      public int getIntermediateCertificateCount() {
        return instance.getIntermediateCertificateCount();
      }
      /**
       * <code>repeated bytes intermediate_certificate = 3;</code>
       * @param index The index of the element to return.
       * @return The intermediateCertificate at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getIntermediateCertificate(int index) {
        return instance.getIntermediateCertificate(index);
      }
      /**
       * <code>repeated bytes intermediate_certificate = 3;</code>
       * @param value The intermediateCertificate to set.
       * @return This builder for chaining.
       */
      public Builder setIntermediateCertificate(
          int index, com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIntermediateCertificate(index, value);
        return this;
      }
      /**
       * <code>repeated bytes intermediate_certificate = 3;</code>
       * @param value The intermediateCertificate to add.
       * @return This builder for chaining.
       */
      public Builder addIntermediateCertificate(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addIntermediateCertificate(value);
        return this;
      }
      /**
       * <code>repeated bytes intermediate_certificate = 3;</code>
       * @param values The intermediateCertificate to add.
       * @return This builder for chaining.
       */
      public Builder addAllIntermediateCertificate(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.addAllIntermediateCertificate(values);
        return this;
      }
      /**
       * <code>repeated bytes intermediate_certificate = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIntermediateCertificate() {
        copyOnWrite();
        instance.clearIntermediateCertificate();
        return this;
      }

      /**
       * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
       * @return Whether the signatureAlgorithm field is set.
       */
      @java.lang.Override
      public boolean hasSignatureAlgorithm() {
        return instance.hasSignatureAlgorithm();
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
       * @return The signatureAlgorithm.
       */
      @java.lang.Override
      public su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm getSignatureAlgorithm() {
        return instance.getSignatureAlgorithm();
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
       * @param value The enum numeric value on the wire for signatureAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureAlgorithm(su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm value) {
        copyOnWrite();
        instance.setSignatureAlgorithm(value);
        return this;
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.SignatureAlgorithm signature_algorithm = 4 [default = RSASSA_PKCS1v15];</code>
       * @return This builder for chaining.
       */
      public Builder clearSignatureAlgorithm() {
        copyOnWrite();
        instance.clearSignatureAlgorithm();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:su.litvak.chromecast.api.v2.AuthResponse)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new su.litvak.chromecast.api.v2.CastChannel.AuthResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "signature_",
              "clientAuthCertificate_",
              "intermediateCertificate_",
              "signatureAlgorithm_",
              su.litvak.chromecast.api.v2.CastChannel.SignatureAlgorithm.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0001\u0002\u0001\u150a\u0000\u0002" +
                "\u150a\u0001\u0003\u001c\u0004\u100c\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<su.litvak.chromecast.api.v2.CastChannel.AuthResponse> parser = PARSER;
          if (parser == null) {
            synchronized (su.litvak.chromecast.api.v2.CastChannel.AuthResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<su.litvak.chromecast.api.v2.CastChannel.AuthResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:su.litvak.chromecast.api.v2.AuthResponse)
    private static final su.litvak.chromecast.api.v2.CastChannel.AuthResponse DEFAULT_INSTANCE;
    static {
      AuthResponse defaultInstance = new AuthResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        AuthResponse.class, defaultInstance);
    }

    public static su.litvak.chromecast.api.v2.CastChannel.AuthResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AuthResponse> PARSER;

    public static com.google.protobuf.Parser<AuthResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AuthErrorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:su.litvak.chromecast.api.v2.AuthError)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
     * @return Whether the errorType field is set.
     */
    boolean hasErrorType();
    /**
     * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
     * @return The errorType.
     */
    su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType getErrorType();
  }
  /**
   * Protobuf type {@code su.litvak.chromecast.api.v2.AuthError}
   */
  public  static final class AuthError extends
      com.google.protobuf.GeneratedMessageLite<
          AuthError, AuthError.Builder> implements
      // @@protoc_insertion_point(message_implements:su.litvak.chromecast.api.v2.AuthError)
      AuthErrorOrBuilder {
    private AuthError() {
    }
    /**
     * Protobuf enum {@code su.litvak.chromecast.api.v2.AuthError.ErrorType}
     */
    public enum ErrorType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>INTERNAL_ERROR = 0;</code>
       */
      INTERNAL_ERROR(0),
      /**
       * <pre>
       * The underlying connection is not TLS
       * </pre>
       *
       * <code>NO_TLS = 1;</code>
       */
      NO_TLS(1),
      /**
       * <code>SIGNATURE_ALGORITHM_UNAVAILABLE = 2;</code>
       */
      SIGNATURE_ALGORITHM_UNAVAILABLE(2),
      ;

      /**
       * <code>INTERNAL_ERROR = 0;</code>
       */
      public static final int INTERNAL_ERROR_VALUE = 0;
      /**
       * <pre>
       * The underlying connection is not TLS
       * </pre>
       *
       * <code>NO_TLS = 1;</code>
       */
      public static final int NO_TLS_VALUE = 1;
      /**
       * <code>SIGNATURE_ALGORITHM_UNAVAILABLE = 2;</code>
       */
      public static final int SIGNATURE_ALGORITHM_UNAVAILABLE_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ErrorType valueOf(int value) {
        return forNumber(value);
      }

      public static ErrorType forNumber(int value) {
        switch (value) {
          case 0: return INTERNAL_ERROR;
          case 1: return NO_TLS;
          case 2: return SIGNATURE_ALGORITHM_UNAVAILABLE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ErrorType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ErrorType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ErrorType>() {
              @java.lang.Override
              public ErrorType findValueByNumber(int number) {
                return ErrorType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ErrorTypeVerifier.INSTANCE;
      }

      private static final class ErrorTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ErrorTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ErrorType.forNumber(number) != null;
              }
            };

      private final int value;

      private ErrorType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:su.litvak.chromecast.api.v2.AuthError.ErrorType)
    }

    private int bitField0_;
    public static final int ERROR_TYPE_FIELD_NUMBER = 1;
    private int errorType_;
    /**
     * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
     * @return Whether the errorType field is set.
     */
    @java.lang.Override
    public boolean hasErrorType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
     * @return The errorType.
     */
    @java.lang.Override
    public su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType getErrorType() {
      su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType result = su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType.forNumber(errorType_);
      return result == null ? su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType.INTERNAL_ERROR : result;
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
     * @param value The errorType to set.
     */
    private void setErrorType(su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType value) {
      errorType_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
     */
    private void clearErrorType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      errorType_ = 0;
    }

    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.AuthError parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(su.litvak.chromecast.api.v2.CastChannel.AuthError prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code su.litvak.chromecast.api.v2.AuthError}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          su.litvak.chromecast.api.v2.CastChannel.AuthError, Builder> implements
        // @@protoc_insertion_point(builder_implements:su.litvak.chromecast.api.v2.AuthError)
        su.litvak.chromecast.api.v2.CastChannel.AuthErrorOrBuilder {
      // Construct using su.litvak.chromecast.api.v2.CastChannel.AuthError.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
       * @return Whether the errorType field is set.
       */
      @java.lang.Override
      public boolean hasErrorType() {
        return instance.hasErrorType();
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
       * @return The errorType.
       */
      @java.lang.Override
      public su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType getErrorType() {
        return instance.getErrorType();
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
       * @param value The enum numeric value on the wire for errorType to set.
       * @return This builder for chaining.
       */
      public Builder setErrorType(su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType value) {
        copyOnWrite();
        instance.setErrorType(value);
        return this;
      }
      /**
       * <code>required .su.litvak.chromecast.api.v2.AuthError.ErrorType error_type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearErrorType() {
        copyOnWrite();
        instance.clearErrorType();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:su.litvak.chromecast.api.v2.AuthError)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new su.litvak.chromecast.api.v2.CastChannel.AuthError();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "errorType_",
              su.litvak.chromecast.api.v2.CastChannel.AuthError.ErrorType.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0001\u0001\u150c\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<su.litvak.chromecast.api.v2.CastChannel.AuthError> parser = PARSER;
          if (parser == null) {
            synchronized (su.litvak.chromecast.api.v2.CastChannel.AuthError.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<su.litvak.chromecast.api.v2.CastChannel.AuthError>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:su.litvak.chromecast.api.v2.AuthError)
    private static final su.litvak.chromecast.api.v2.CastChannel.AuthError DEFAULT_INSTANCE;
    static {
      AuthError defaultInstance = new AuthError();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        AuthError.class, defaultInstance);
    }

    public static su.litvak.chromecast.api.v2.CastChannel.AuthError getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AuthError> PARSER;

    public static com.google.protobuf.Parser<AuthError> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DeviceAuthMessageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:su.litvak.chromecast.api.v2.DeviceAuthMessage)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Request fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
     * @return Whether the challenge field is set.
     */
    boolean hasChallenge();
    /**
     * <pre>
     * Request fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
     * @return The challenge.
     */
    su.litvak.chromecast.api.v2.CastChannel.AuthChallenge getChallenge();

    /**
     * <pre>
     * Response fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
     * @return Whether the response field is set.
     */
    boolean hasResponse();
    /**
     * <pre>
     * Response fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
     * @return The response.
     */
    su.litvak.chromecast.api.v2.CastChannel.AuthResponse getResponse();

    /**
     * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
     * @return Whether the error field is set.
     */
    boolean hasError();
    /**
     * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
     * @return The error.
     */
    su.litvak.chromecast.api.v2.CastChannel.AuthError getError();
  }
  /**
   * Protobuf type {@code su.litvak.chromecast.api.v2.DeviceAuthMessage}
   */
  public  static final class DeviceAuthMessage extends
      com.google.protobuf.GeneratedMessageLite<
          DeviceAuthMessage, DeviceAuthMessage.Builder> implements
      // @@protoc_insertion_point(message_implements:su.litvak.chromecast.api.v2.DeviceAuthMessage)
      DeviceAuthMessageOrBuilder {
    private DeviceAuthMessage() {
    }
    private int bitField0_;
    public static final int CHALLENGE_FIELD_NUMBER = 1;
    private su.litvak.chromecast.api.v2.CastChannel.AuthChallenge challenge_;
    /**
     * <pre>
     * Request fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
     */
    @java.lang.Override
    public boolean hasChallenge() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Request fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
     */
    @java.lang.Override
    public su.litvak.chromecast.api.v2.CastChannel.AuthChallenge getChallenge() {
      return challenge_ == null ? su.litvak.chromecast.api.v2.CastChannel.AuthChallenge.getDefaultInstance() : challenge_;
    }
    /**
     * <pre>
     * Request fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
     */
    private void setChallenge(su.litvak.chromecast.api.v2.CastChannel.AuthChallenge value) {
      value.getClass();
  challenge_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <pre>
     * Request fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeChallenge(su.litvak.chromecast.api.v2.CastChannel.AuthChallenge value) {
      value.getClass();
  if (challenge_ != null &&
          challenge_ != su.litvak.chromecast.api.v2.CastChannel.AuthChallenge.getDefaultInstance()) {
        challenge_ =
          su.litvak.chromecast.api.v2.CastChannel.AuthChallenge.newBuilder(challenge_).mergeFrom(value).buildPartial();
      } else {
        challenge_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Request fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
     */
    private void clearChallenge() {  challenge_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int RESPONSE_FIELD_NUMBER = 2;
    private su.litvak.chromecast.api.v2.CastChannel.AuthResponse response_;
    /**
     * <pre>
     * Response fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
     */
    @java.lang.Override
    public boolean hasResponse() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Response fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
     */
    @java.lang.Override
    public su.litvak.chromecast.api.v2.CastChannel.AuthResponse getResponse() {
      return response_ == null ? su.litvak.chromecast.api.v2.CastChannel.AuthResponse.getDefaultInstance() : response_;
    }
    /**
     * <pre>
     * Response fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
     */
    private void setResponse(su.litvak.chromecast.api.v2.CastChannel.AuthResponse value) {
      value.getClass();
  response_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <pre>
     * Response fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeResponse(su.litvak.chromecast.api.v2.CastChannel.AuthResponse value) {
      value.getClass();
  if (response_ != null &&
          response_ != su.litvak.chromecast.api.v2.CastChannel.AuthResponse.getDefaultInstance()) {
        response_ =
          su.litvak.chromecast.api.v2.CastChannel.AuthResponse.newBuilder(response_).mergeFrom(value).buildPartial();
      } else {
        response_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Response fields
     * </pre>
     *
     * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
     */
    private void clearResponse() {  response_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int ERROR_FIELD_NUMBER = 3;
    private su.litvak.chromecast.api.v2.CastChannel.AuthError error_;
    /**
     * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
     */
    @java.lang.Override
    public boolean hasError() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
     */
    @java.lang.Override
    public su.litvak.chromecast.api.v2.CastChannel.AuthError getError() {
      return error_ == null ? su.litvak.chromecast.api.v2.CastChannel.AuthError.getDefaultInstance() : error_;
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
     */
    private void setError(su.litvak.chromecast.api.v2.CastChannel.AuthError value) {
      value.getClass();
  error_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeError(su.litvak.chromecast.api.v2.CastChannel.AuthError value) {
      value.getClass();
  if (error_ != null &&
          error_ != su.litvak.chromecast.api.v2.CastChannel.AuthError.getDefaultInstance()) {
        error_ =
          su.litvak.chromecast.api.v2.CastChannel.AuthError.newBuilder(error_).mergeFrom(value).buildPartial();
      } else {
        error_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
     */
    private void clearError() {  error_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code su.litvak.chromecast.api.v2.DeviceAuthMessage}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage, Builder> implements
        // @@protoc_insertion_point(builder_implements:su.litvak.chromecast.api.v2.DeviceAuthMessage)
        su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessageOrBuilder {
      // Construct using su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Request fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
       */
      @java.lang.Override
      public boolean hasChallenge() {
        return instance.hasChallenge();
      }
      /**
       * <pre>
       * Request fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
       */
      @java.lang.Override
      public su.litvak.chromecast.api.v2.CastChannel.AuthChallenge getChallenge() {
        return instance.getChallenge();
      }
      /**
       * <pre>
       * Request fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
       */
      public Builder setChallenge(su.litvak.chromecast.api.v2.CastChannel.AuthChallenge value) {
        copyOnWrite();
        instance.setChallenge(value);
        return this;
        }
      /**
       * <pre>
       * Request fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
       */
      public Builder setChallenge(
          su.litvak.chromecast.api.v2.CastChannel.AuthChallenge.Builder builderForValue) {
        copyOnWrite();
        instance.setChallenge(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Request fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
       */
      public Builder mergeChallenge(su.litvak.chromecast.api.v2.CastChannel.AuthChallenge value) {
        copyOnWrite();
        instance.mergeChallenge(value);
        return this;
      }
      /**
       * <pre>
       * Request fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthChallenge challenge = 1;</code>
       */
      public Builder clearChallenge() {  copyOnWrite();
        instance.clearChallenge();
        return this;
      }

      /**
       * <pre>
       * Response fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
       */
      @java.lang.Override
      public boolean hasResponse() {
        return instance.hasResponse();
      }
      /**
       * <pre>
       * Response fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
       */
      @java.lang.Override
      public su.litvak.chromecast.api.v2.CastChannel.AuthResponse getResponse() {
        return instance.getResponse();
      }
      /**
       * <pre>
       * Response fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
       */
      public Builder setResponse(su.litvak.chromecast.api.v2.CastChannel.AuthResponse value) {
        copyOnWrite();
        instance.setResponse(value);
        return this;
        }
      /**
       * <pre>
       * Response fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
       */
      public Builder setResponse(
          su.litvak.chromecast.api.v2.CastChannel.AuthResponse.Builder builderForValue) {
        copyOnWrite();
        instance.setResponse(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Response fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
       */
      public Builder mergeResponse(su.litvak.chromecast.api.v2.CastChannel.AuthResponse value) {
        copyOnWrite();
        instance.mergeResponse(value);
        return this;
      }
      /**
       * <pre>
       * Response fields
       * </pre>
       *
       * <code>optional .su.litvak.chromecast.api.v2.AuthResponse response = 2;</code>
       */
      public Builder clearResponse() {  copyOnWrite();
        instance.clearResponse();
        return this;
      }

      /**
       * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
       */
      @java.lang.Override
      public boolean hasError() {
        return instance.hasError();
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
       */
      @java.lang.Override
      public su.litvak.chromecast.api.v2.CastChannel.AuthError getError() {
        return instance.getError();
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
       */
      public Builder setError(su.litvak.chromecast.api.v2.CastChannel.AuthError value) {
        copyOnWrite();
        instance.setError(value);
        return this;
        }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
       */
      public Builder setError(
          su.litvak.chromecast.api.v2.CastChannel.AuthError.Builder builderForValue) {
        copyOnWrite();
        instance.setError(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
       */
      public Builder mergeError(su.litvak.chromecast.api.v2.CastChannel.AuthError value) {
        copyOnWrite();
        instance.mergeError(value);
        return this;
      }
      /**
       * <code>optional .su.litvak.chromecast.api.v2.AuthError error = 3;</code>
       */
      public Builder clearError() {  copyOnWrite();
        instance.clearError();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:su.litvak.chromecast.api.v2.DeviceAuthMessage)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "challenge_",
              "response_",
              "error_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0002\u0001\u1009\u0000\u0002" +
                "\u1409\u0001\u0003\u1409\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage> parser = PARSER;
          if (parser == null) {
            synchronized (su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:su.litvak.chromecast.api.v2.DeviceAuthMessage)
    private static final su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage DEFAULT_INSTANCE;
    static {
      DeviceAuthMessage defaultInstance = new DeviceAuthMessage();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DeviceAuthMessage.class, defaultInstance);
    }

    public static su.litvak.chromecast.api.v2.CastChannel.DeviceAuthMessage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DeviceAuthMessage> PARSER;

    public static com.google.protobuf.Parser<DeviceAuthMessage> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
